# ITKST53
Säilö ITKST53-kurssin palautuksille
## Luento 1
Turvallisuus määriteltiin seuraavasti: jonkin tehtävän tai tavoitteen saavuttaminen huolimatta mahdollisista uhkatekijöistä. Mielesäni uhka voi olla muutakin kuin hyökkääjä, mutta tällä kurssilla keskitytään lähinnä ns "bad actor" tilanteeseen. Luennolla esiteltiin tapa ajatella turvallisuutta seuraavista näkökulmista:

* **policy:** tavoite, tarkoitus, toiminnan määrittely. Näitä voi olla vaikka tiedon luotettavuus tai pääsyoikeuksien määrääminen. Policy määrää mitä mekanismi pyrkii saamaan aikaan, eli mekanismi siis toteuttaa policyä. Hyökkääjä voi pyrkiä hyväksikäyttämään tai rikkomaan tätä policyä, jota yritetään mallintaa uhkamallin avulla.
* **uhkamalli:** malli tai kuvitelma mitä uhka/hyökkääjä voi tehdä tai pyrkii tekemään. Vaikea luoda täydellistä uhkamallia, etenkin jos järjestelmä ei toimi tyhjiössä, kuten näytettiin esimerkkinä luonnolla salasanan nollaamisesta ja ukloisten järjestelmien hyväksikäytöstä. Uhkamalli ovat lähinnä olettamuksia.
* **mekanismi:** järjestelmä tai ohjelmisto, jolla valittu policy taataan. Mekanismeja voivat olla pääsynhallinta, salaus, tilit ja niiden käyttöoikeuksien erottaminen. Mekanismeissa voi olla aukkoja, joita ei huomioitu uhkamallissa. Mekanismin ei välttämättä tarvitse olla vedenpitävä, kunhan voidaan väsyttää hyökkääjä. Ei taida toimia hyvin varustautunutta/valtion tukemaan hyökkääjää vastaan. Yleisesti on hyvä pyrkiä käyttämään mekanismeja pienentämään tai kuristamaan hyökkäyspinta-alaa.

Vaikeus syntyy uhkamallien laajuudesta ja voidaanko ennustaa tai arvioida hyökkääjän käyttäytymistä? Policy voi sallia hyökkääjän toimia, joten sitä suunnitellessa pitäisi hahmottaa tietoturvallinen malli. Esimerksi salasanajärjestelmässä jäähyjen käyttä arvausyrityksiä vastaan on hyvä keino parantaa turvallisuutta laajamittaista useiden tilien murtautumista vastaan. Tosin tästä voi olla vähemmän hyötyä, jos hyökkäys on kohdistettu. Muiden järjestelmien kanssa toimittaessa pitäisi omat systeemit/politiikat kehittää siten, että kriittisessä toiminnassa, kuten tilinhallinassa ei olla riippuvaisia muiden järjestelmien paljastamista tiedoista. (esim. jos tilin palautukseen riittää tieto, joka on saatavilla muista järjestelmistä, voi politiikan uudelleen miettiminen olla paikallaan. Luentoesimerkeissä ei ilmeisesti aina kyetty asettamaan hyökkääjän asemaan).

Hyviä esimerkkejä uhkamallin ongelmista olivat esitellyt heikkoudet salauksen vahvuudessa/ sertifikaattien luotettavuudessa jotka yhdistyivät nätisti mekanismeihin. Käyttäjän toimet osana uhkamallia ovat myös kiinnostava näkökulma. Kuinka järjestelmän toiminta pitäisi suunnitella, jos käyttäjä voidaan huijata toimimaan sitä vastaan? Nähtävsti varmin tapa on määritellä oikeudet siten, että käyttäjä ei kykene yksin sabotoimaan järjestlemää. Uhkamallien pitäisi myös huomioida, että hyökkääjä hallitsee laitteen, jolla palvelun kanssa kommunkoidaan. Eli uhkamalli on suunniteltava siten, että palvelupyynnöt eivät ole ain oikein muotoiltuja. Uhkamalli jossa hyökkääj toimii käyttäjän välineillä ei ole realistinen.

Mekanismien ongelmat esiintyvät virhetilanteina tai bugeina. Luentoesimerkki applen icloud salananan arvausrajapinnasta, joka ei toteuttanut muiden rajapintojen tavoin salananan arvaukseen liittyvää policyä, tai citigroup palvelu, jossa ei tarkistettu sessiota ovat esimerkkejä räikeistä ja helposti ymmärrettävistä virheistä.

Mielestäni tämä merkitsee, että usein ei voida rakentaa täysin vedenpitävää järjestelmää. Hyökkääjän käyttämät menetelmät eivät aina vastaan oletusta ja käytetyillä työkaluilla(tarkistus, auditointi, ohjelmointikieli missä ei voida suoraan käsitellä muistiosoitteita/pinoa) voidaan karsia joitain riskitekijöitä. Kuitenkin pelikenttä on silti usein liian laaja ja nojautuminen yhteen mekanismiin on huono idea. Tekninen velka ja kolmannen osapuolen järjestelmät jo itsessään kehottavat rajoittamaan yhden järjestelmän murtumisen vaikutusta(mekanismit tässä: service accounts, eri kerrokset, järjestelmän eristäminen). Tällä kerralla hieman avattu ideaa, jonka mukaan ohjelmointikielen hallitseminen itsessään ei riitä, vaan on tunnettava sen erityspiirteitä. Keinoja näiden varalle voivat olla paremmat työkalut, parempi tietotaito tai kattavempi testaus. Työkaluilla tarkoitan siis kääntäjän tai kehitysympäristön tarjoamia varoituksia tunnetuista epäturvallista tavoista. Tietotaidon parantaminen on itsestäänselvyys mutta käytännössä hyökkääjien mekanismit ovat niin syvällä, että vähemmän kokenut ohjelmoija tulee tekemään virheitä. Sen lisäksi esimerkit ja (vanhentuneet?) oppaat saattavat ohjata aloittelijan väärälle tielle, josta palaaminen on vaikeampaa. 

## Luento 2
Ylivuodot (c/c++) ovat ohjelmointikielen ominaisuuksia, jossa muistiosoitteet ovat ohjelmoijan käsiteltävissä (huonon koodin kautta täten myös hyökkääjän). Perusesimerkki ylivuodosta on bufferin, tai array:n täyttäminen yli sille varatun rajan. Hyväksikäyttö hyödyntää x86-arkkitehtuurin tuntemusta ja laitteistopinon manipulointia. Aikasemmassa luennossa(luentoäiväkirjamerkinnässä) mainittiin ylivuotoja vastaan suojautuminen käyttämällä ohjelmointikieltä, joka ei palajasta raajoja muistiosoitteita. Tämä helpottaa ohjelmoijan työtä, mutta samalla siirtää vastuun kielen runtime-ympäristön päälle ja jos tarvitaan kirjastoja, jotka eivät käytä mem-safe kieltä, voidaan vain luottaa että ylivuotoja ei voi tapahtuma kolmannen osapuolen koodissa.
 
Ylivuotoja varten päätin kerrata(ja usein syventyä uuteen asiaan) miten ylivuodot tapahtuvat ja mitä mekanismeja siinä käytetään. Pino ja sen kehykset kyllä muistuivat mutta (myöhemmille luennoilla käytävät) rekisterit ja järjestelmäkutsut vaativat pidemmän hetken. Tämä oli tärkeä sillä os labran tehtävistä (joita en siis palauta kurssin suoritusta varten mutta teen ja katselen omaan tahtiin, riippuen ajasta ja mielenkiinnosta) vaativat syvällistä tietoa rekistereistä. Aikamoinen hyppäys, jos eniten ohjelmointikokemusta on muistiturvallisista kielistä :-/. 
 
Ylivuotojen välttämiseen ehdotettiin bugien välttämistä. Erinomainen ehdotus, onnistunee mahdollisesti pienempien sovelluksien kanssa mutta kuten luennolla 1 mainittiin, niin nykyiset järjestelmät ovat entistä monimutkaisiempia. Ja kuten on tullut esille, hyökkääjän hyväksikäyttämät bugit ovat syvällä ohjelmointikielen yksityiskohdissa. Tämä on jo yksi syy, miksi bugiton ohjelmointi on haave, kaunis uni. Myös materiaali, jonka pohjalta on kukin opiskellut voi osaltaan vaikuttaa(vaikeuttaa) bugien välttämistä. Toinen tapa (pyrkiä) estämään ylivuotoja mahdollistavat bugit on analysoida ohjelmallisesti kirjoitettu lähdekoodi ja käyttää saatuaj tietoja testauksen alustamiseen tai ohjelmoidan varoittamiseen. Hyvä muistutus on pyrkiä ulottamaan testaus ohjelman suorituspuun jokaiselle "oksalle". Viimeinen esitelty tapa on käyttää ohjelmointikiletä ja ympäristö missä ylivuotoja ei tapahtudu, koska kirjoitettuohjelma ei käsittele suoraan muistia tai sen osoittimia.
 
Baggy bounds oli uusi asia ja tuotti kyllä hieman vaikeuksia hahmottaa sen toimintaperiaatetta kokonaisuudessaan julkaisua lukemalla (kuten luennoitisija mainitisi). Perusperiaate on varata muistia 2^x lohkoissa ja osoitin operaation kohdalla tarksitetaan onko osoitin sille varatulla alueella. Tämä varattu alue tod. on isompi, kuin itse objekti. Baggy bounds rajojen ulkopuolelle jäävät osoittimet merkitään siten, että niitä ei käsitellä. Tämän metodin ongelma on, että se vaatii kääntäjän tuen. Uskoakseni NX-mem ja erinäiset muistiavaruuden hajautusmenetelmät ovat yleisempiä. Syy on todennäköisesti, että vaikka baggy bounds aiheuttaa muihin vastaviin menetelmiin nähden vähemmän hävikkiä, on kehittäjille silti helpompi käyttää muita menetelmiä (kuten: DEP, aslr).  Luennolla 3 käytiin sen periaatetta tarkemmin läpi, joten säästän sinne tarkemman kirjoittelun. Tosin tässä on huomattavaa, että missä NX-muisti (non-exec) suojaa injektoidulta, hyökkääjä voi silti hyödyntää ohjelman muistissa sijaitsevia (tai ladattujen kirjastojen muistissa) olevia palasia (myöhemillä kerroilla kutsuttiin gadget:ksi, suomeksi vehje?), eli ROP.
 
Kuitenkin canaries periaate on looginen ja aikaisemmin tuttu wiki-artikkelien pohjalta. Myöskin sen ongelmat, eli jos canaryn arvo on staattinen tai ennaltaarvattava (kiinnostava idea oli käyttää jotain signaalia esimerksi istunnon tai socketin sulkemista signaalina staattisen canaryn etsimisessä. Myös pinon tilasta vuotavat menetelmät olivat uusia tuttavuuksia minulle, joku string-format metodi. Tarvittiin tarkempi tarkastelu OWASP-wikissä idean selvittämiseksi. Muistan lapsuudesta erään verkkopelin, jossa serveri saatiin kaadettua kirjoittamalla yleiseen chattiin %n%n%n%n%n%n, joka taitaa liittyä juurin tähän string format menetelmään). Muita keinoja, joissa tallennetaan muistin varauksen yhteydessä varatun muistin koko erilliseen tietueeseen on esitetty mutta niillä on oma suorituskyky/muistin tarpeensa (tarpeeksi iso, jotta tekniikkaa ei voida käyttää tuotannossa tai kriittisissä sovelluksissa).

## Luento 3

Luennolla kolme jatkettiin baggy bounds mekanismin kanssa ja tarkasteltiin erinäisiä ylivuoto suojauksia ja niitä vastaan kehitettyjä tekniikoita. Hyökkäystekniikoista oli tarkemmin käsittelyssä return oriented programming:n sokea muunnos, jossa rop-metodeja sovellettiin etäkohteeseen, hyödyntämällä kohdepalvelun toimintaa signaalina. Signaali voi olla yhteyden sulkeutuminen (palvelin kaatui) tai pysäytys (stop-vetkuttimen etsimisessä). Vartijalohko(canary):n kukistamiseen ehdotettiin ympäristössä, missä canary on 8-tavuinen, raanvoiman käyttöä arvauksessa, jos voidaan tunnistaa väärä bitin arvon arvaus jollain mekanismille (kuten kaatuminen). Oletuksena siis että palvelu käynnistetään kaatumisen jälkeen uudestaan ja sen prosessin osoiteavaruus, sekä canary ei muutu näiden käynnistyksien välillä (huom! fork() vs execv(), missä fork()). Baggy bounds systeemi, etenkin 64-bittisessä ympäristössä, missä osoittimen rajat sisällytetään siihen itseensä, ylempiin bitteihin. Etuina mm. osoittimen välitys BB ja non-BB koodin välillä. Tosin luennolla mainittu 64-bittisen osoittimen rakenna ja selitys, että tietyt bitit voivat olla pakosta 0 jäi hieman mietityttämään. Ainakin BROP-paperi linjaa normaaleilla prosesseilla ensimmäiset 2 tavua nolliksi. Muut hyökkäyskeinot kuten funktion osoittimen ylikirjoitus, kiertävät canaryn koska hyökkääjän ei tarvitse ylittää canaryä muokatakseen ret.addr:ää. BROP-paperi tosin mainitsi, että bufferi (joka ylivuotaa) yleensä sijoitetaan pinossa siten, että ylivuoto ei osu muihin muuttujiin ennen canaryä.

Hyökkääjän koodin injektion estoon tarkoitettu NX-stack voidaan kiertää hyödyntämällä olemassa olevaa koodia(palasia, kuten tiettyjä operaatiokoodeja, pop,$eax; ret yms.). Hyökkääjä muokkaa pinoa siten, että haluttu sekvenssi näitä olemassa olevia opkoodeja suoritetaan. Muutenkin keinot, jotka ovat automaattisesti (tai oletuksena) päällä ja eivät aiheuta vääriä hälyytyksiä ovat yleisempiä. Mainittiin myös, että on todennäköistä että ohjelma tukee osoiteavaruuden satunnaissekoitusta (poislukien tapaukset missä tarvitaan tiettyä muistiosoitetta mm. ajurit tai muut lähellä rautaa toimivat komponetit). 

Pop; ret; yms vekottimet tuppaavat aiheuttamaan hieman harmaita hiuksia. Niiden käyttökohde on kuitenkin (BROP-paperissa) pinon saattaminen tilaan, jolla voidaan luoda (64-bittisessä arkkitehtuurissa) järjestelmäkutsu valituilla argumenteilla. Monissa tapauksissa itse hyökkäys käyttää useita tekniikoita hyväksi. Kun threat model BROP:ssa ja muissa hyökkäyksissä missä hyökkääjä useilla arvauksilla kiertää satunnais- yms muut suojaukset, että palvelimelle voi lähettää useita arvauksia, tai muuten tökkiä sitä ja reaktiosta päätellään jotain. Ilmeinen vastatoimi olisi siis uudelleensekoitus uuden lapsiprosessin luomisen yhteydessä, kenties poikkeavan toiminnan tunnistaminen jollain menetelmällä voisi toimia? Itseasiassa yllätyin, kuinka monipuolisesti ilmaisia työkaluja tämän mallisien hyökkäyksien ja payloadien rakentamiseen on yleisessä jakelussa olevassa metasploit-ympäristössä. Esimerksi msfconsole:lla voidaan generoida hyökkäyskoodi, sekä määritellä kielletyt tavut (esimerkiksi \0, jos ylivuoto tapahtuu merkkijonoa käsitellevässä komponetissa missä \0 tavu lopettaa tavujen kirjoittamisen muistiin).

Yhteenvetona kolmesta ensimmäisesti luennosta voisin vetää, että esitellyt mekanismit (BROP, canary, yms) tekevät joitain olettamuksia palvelimen toimista. Toisin sanoen hyökkäyksille on määritelty threat model. Esitellyt menetelmät voidaan kukistaa elimoimalla ylivuodot, bugittomalla ohjelmoinnilla, rajojen tarkastuksella, tai muilla keinoilla. Koska hyökkäyksillä uhkamallissa tehtiin muutama oletus, voidaan ne hyökkäykset estää tekemällä muutoksia kohdejärjestelmään (osoitteistuksen uudelleen hajautus, ei käytetä fork():a joka perii vanhemmalta prosessilta yms). Tosin heap-ruiskutus voi toimia myös näissä tapauksissa, monimutkaisia juttuja.. Myös entropian määrä on mietittävä asia, esimerkkinä annettiin hash-funktiolle annettava seed, joka on tällä kertaa timestamp, joka vähentää tuntemattomien bittien määrää reilusti. On myös myönnettävä, että ennen luentoja tunsin vain normaalin ylivuodon, jossa shellcode injektoidaan sekä hypyn johonkin olemassa olevaan osoitteeseen. Vekottimet (gadget) tulivat siis uutena asiana ja hyödynsivät konsepteja, joita ylemmän abstraktiotason kanssa työnskentelevät eivät aina ajattele. <del>Jos ei mitään muuta ota päähän, niin edes se vanha totuus että seuraavia metodeja ei kannata koskaan käyttää (oman puuhastelun ulkopuolella, eikä silloinkaan kannata, ettei jää paha tapa).</del> Päivitys: taitaa olla järkevämpi jättää pahojen metodien tarkistus ja kirjanpito ohjelmiston hoidettavaksi käyttämällä vaikka banned.h tai vastaavaa keinoa varoittamaan, jos on sattunut kömmähdys.

Sen lisäksi voidaan hyödyntää staattista tarkistusta tai muita työkaluja etsimään mahdollisia ylivuodon kohteita, tai käyttämään syötteenä erinäisille rajojen tarkistus menetelmille. Toisin sanoen siis koska rajojen tarkistus aiheuttaa suorituskyky hävikkiä, kohdennetaan tarkistus tunnettuihin komponetteihin ja jätetään tarkistukset pois niiltä koodipoluilta, joiden osalta voidaan olla varmuja, ettei hyökkääjä pääse niistä hyötymään. Ehkä helpointa on arvioida, jos sovellus, joka on käyttää käyttäjän syöttämää dataa (tätähän voitaisiin suodattaa tai kkäsitellä, sen sijaan että siihen luotetaan..) voidaan ohjelmoida käyttämällä muistiturvallisia kieliä ja välttää c-kielisiä kirjastoja. Noh, aina saa unelmoida.

## Luento 4

Oikeuksien hallinta järjestelmänäkökulmasta, on idea missä järjestelmän komponenttien oikeuksia tai mahdollisuuksia rajoitetaan mahdollisimman paljoan, estämättä toiminnallisuutta. Aikaisemmin on tullut esille, että jos hyökkääjä voi suorittaa omaa koodia tai hyödyntää olemassa olevia vekottimia, niin nämä toiminnon suoritetaan haavoittuneen prosessin oikeuksilla. Unix:ssa, johon liittyy tuleva asia, proesssilla on yksi omistaja ja mahdollisesti useita ryhmiä, missä inode:lla (tiedsotot ja hakemistot) on vain yksi omistaja ja ryhmä. Oikeuksien vähentäminen ja prosessien ajaminen mahdollisimman vähillä oikeuksilla on erityisen tärkeää, jos kyseinen prosessi tekee jotain käyttäjältä tulevan syötteen kanssa. Ohjelmointivirheet, tai (oudot ja ihmeelliset) policy:t (case: https://www.evilsocket.net/2017/05/30/Terramaster-NAS-Unauthenticated-RCE-as-root/) missä web-hallintapaneelin (php) kautta voidaan lähettää tiedostoja (mihin tahansa sijaintiin), kunhan cookie[kod_name] on olemassa (mikä tahansa arvo käy). Esimerkin ongelmat, jotka liittyvät tämän kertaisen luennon aiheisiin: 
* tiedostoja voitiin lähettää mihin tahansa sijaintiin tiedsotojärjestelmässä. Mahdollistaa omien .php tiedostojen suorittamisen lisäämällä ne /usr/www/ hakemistoon ja kutsumalla niitä. Tässä olisi voitu rajoittaa vastaanottaminen omaan hakemistoonsa käyttämällä chroot:ia.
* web-palvelin on käynnistetty root:na, jolloin voidaan suorittaa haluttuja komentoja pääkäyttäjän oikeuksilla käyttämllä esimerksi php system() komennolla.

Merkittävin ongelma on tietenkin kelvoton käyttäjän autentikointi, mutta sopivalla menettelyllä oltaisiin voitu hidastaa hyökkääjää.  

Unix:in oikeuksien hallinta kuvattiin kohteen (subject), objektin (file, file descriptors, prosessit ja minusta yksi objekti, joa jäi välistä olisi käyttäjätilit). Prossessilla on yleensä yksi käyttäjätunnus (uid) ja useampi ryhmätunnus, jotka määrittelevät prosessin oikeudet. Unix tiedostoilla/hakemistoilla on omistaja ja ryhmä(uid ja gid) ja permission(matriisi/table, rwx-maski miten sen nyt ottaa). Omistajalla on ainoat oikeudet muuttaa oikeuksia. File descriptor on tavallaan kahva johonkin tiedostoon, joka voidaan ohjata muille. Tällä tavalla, kuten luennoitsija kertoi, voidaan rajoittaa prosessin pääsyä tiedostoihin. Yksi teema on nähtävissä jo alkuluennosta, eli eristäminen, oli kyse sitte nteidostoista tai prosesseista tai niiden muistista. Verkkojen kanssa voidaan avata yhteyksiä (periaatteessa) rajatta. Alhaisien <1024 porttien kuuntelu on rajoitettu tietyille käyttäjille (missä super user / root kävelee tarkistuksien ohi). Käyttäjätunnukset (uid) voidaan määrittää prosessille järjestelmläkäskyllä. Chroot -komento toimii tavallaan komerona, eli komento tavallaan muokkaa miten /-käsitellään. Missä / osoittaa takasin itseensä, jolloin juuren / käsite muuttuu tälle prosessille. 

OKWS-kehys pyrkii jakamaa tyypillisen palvelimen komponentit useiksi käyttäjiksi, tarkoituksena eristää www-palvelin tietokannasta tiedostojärjestelmän näkökulmasta. Koska jos palvelimen kaikki komponentit suoritetaan samalla omistaja käyttäjällä, yhden komponentit kautta hyökkääjä saa nämä oikeudet myös muiden sillä suoritettujen proesssien tietoihin. OKWS:ssä pyyntö käsitellään okd-prosessin taholta, joka ohjaa pyynnön lokikompontentille, tai palvelulle. Palvelut käyttävät tietoakntaa välittäjäkomponentin kautta. Ideana on eristää tietokanta ja rajoittaa sen suoraa käyttöä vain tietylle proessille. Mainittiin, että OKWS:ssä jokaisella prosessilla ja palvelulla on oma käyttäjätunnus uid.

Muuteknin oikeuksien rajaaminen ja eristäminen on mielekästä ja sinänsä turvallisempaa, jos onnistunut hyökkäys vaatii useden käyttäjien kaappauksen. Kenties tästä kaappauksesta tai sen yrityksestä jää tarkemmat lokitiedostot jälkiselvitystä varten, esimerkiksi soveltamalla videon opiskelijanan ideaa missä lokitiedostoon kirjoittava komponetti voi vain lisätä rivejä lokitiedostoon hyödyntämällä unix:in oikeuksienhallintaa. Sinänsä groupid tuo mieleen active directoryn, jossa on myös käyttäjäkohtaisia ja ryhmäkohtaisia rajoituksia, oikeuksia ja rajoituksia. Kuten on aiakisemmin tullut esille, tässä on pääasiassa nähtävästi tarkoituksena asettaa mahdollisimman monta estettä hyökkääjälle ja rajoittaa/pitää mahdollinen vahinko kontrollissa. Monet OKWS-järjestelmän ratkaisut tähtäävät tähän toiminnallisuuden eritämiseen, esimerkiksi staattinen ja dynaaminen sisältökin on erotettu, pubd toimii vain templaattien jakelijana. Palvelimelle määritellyt "periaatteet" principles (outo termi tähän yhteyteen, vaikeahko ymmärtää sen tarkoitusta), siis pyrkivät suojaamaan muita komponentteja ja tiedostoja/tietoja ohjelmoointivirheiden seurauksilta. Tähän viitataan OKWS-paperissa kappaleessa 2.2, missä mietitään voiko apache, php, olla virheettömiä ja ratkaisevat näin ongelmat. 

## Luento 6

Oikeuksiin liittyy useita ongelmia, jossa yhdessä prosessilla voi olla kaksi erilaista oikeutta ja vaikeudet syntyvät kumpaa oikeutta pitäisi käyttää. Prosessilla oi olla laajemmat oikeudet, kuin sitä ohjastavalla käyttäjällä, jolloin käyttävä voi esimerksi avata prosessiin tiedostoja, jotka eivät ole käyttäjän normaalien oikeuksien rajoissa. Ambient authority, varmaan suomentamalla leijuvat oikeudet, määritellään oikeuksiksi, joita prosessi käyttää automaattisesti. Tämä voi esiintyä vaikka oikeutena avata tietty tiedosto jostain hakemistosta. Tämä luo ongelman, jossa on haastavaa hallita tarkasti miten prosessi voi käyttäytyä, jos sillä on jotain oikeuksia joita käytetään tarvittaessa. Yksi ratkaisua jota voidaan ajatella on, manittu fd:den käyttäminen tiedostonimien sijasta. Tällöin prosessi jolla on  käytössään jokin fd, on myös todennettavasti ollut oikeudet avata se (fd:n saaminen käyttöön, itse avaamalla tai muulta prosessilta, tarkoittaa että avaavan prosessin oikeudet siihen tarksitetaan avauksen yhteydessä).

Capability määritellään: väärentämätön osoitus jostain oikeudesta tai valtuutuksesta. Luennoilla käsiteltiin lähinnä jaettuna file descriptionina, missä suorittavalla komponetilla ei ole yhtään ylimääräisiä oikeuksia ja tarvittavien tiedostojen aukaiseminen suoritetaan siihen tarkoitetulla kompontentilla. Nähtävästi asettaa haasteita muun muassa kääntäjille. 

Virtualisoinnin käyttäminen eristykseen, kun moista tarvitaan, mutta ei sovellu (helposti) tapauksiin missä pitää antaa oikeuksia tiettyihin tiesotoihin, tai jakaa tietoa useiden vm:ien välillä. Verkkokerroksen eristys voi olla hankalampaa. Sockettien kuuntelu on yksi toimenpide missä tarvitaan laajempia oikeuksia. 

Global namaspaces: tiedostojärjestelmä -> vaikea kontrolloida oikeuksia, prosessin uid ja objektien omat oikeudet/asetukset, voi olla rajaton, capsicum tarkoitus on pyrkiä kohti "file description" -mallia, missä globalia namespaceä ei ole käytössä. 

Capsicum on framework, jonka tarkoitus on vähentää epäluotettavan koodin oikeuksia ja näin pienentää hyökkäyspinta-alaa. Rajoittamalla oikeuksia voidaan kitkeä tapauksia missä kaapattu prosessi vaikuttaa muihin saman käyttäjän käynnistämiin prosesseihin. Käytännössä siis epäilyttävän (ulkopuolisen, syötettä käsitteleven tai monimutkaisen ja täten mahdollisesti bugisen) koodin suorittaminen tapahtuu ersitetyssä hiekkalaatikossa. Capsicum vaatii muutoksia ohjelmien toteutukseen mutta tarjoaa niihn valmiin kehyksen. Se laajentaa fd:tä sisältämään niin sanotun capabilityn, jolla voidaan määritellä tarkemmin sallitut operaatiota tietylle fd:lle. Capsicum toimii muutamassa vaiheessa:
* määritellään ja annetaan oikeudet
* siirrytään rajoitettuun tilaan kutsulla cap_enter

Rajoitetussa tilassa kyseinen prosessi (ja sen jälkeläiset) eivät voi tehdä muutoksia tai niille ei voida antaa uusia oikeuksia. Eli ennen tähän tilaan siirtymistä pitää avata ja lähettää tarvittavat fd:t. Capsicum voidaan toteuttaa joko kirjastolla, tai ytimen tasolla (cap_enter). Kirjasto ei suojaa, jos ohjelmoija ei huomaa käyttää sitä tehokkaasti tai jos suoritetaan kolmannen osapuolen koodia. Fd lists vaati hieman pohdintaa, videolla se selitettiin abstraktioksi, jossa fd (joka on numero) esitetään paremmin ymmärrettävänä nimenä, joka on ilmeisesti vielä hierarkkinen. Kenties se voi olla tutumpaa muotoa "fd.int : dir.dir.file.string"? Toinen seikka mikä nostettiin esille on kuinka käsitellään usea prosessille syötetty fd. Miten siis erotetaan ne toisistaan, käytetäänkö tiettyä järjestystä niin lähettämisessä (vrt. 0 - input, 1 - output, 2 - error.out), tai listoja tai array:tä?

Koska capsicum tekee muutoksia ytimeen, joilla saadaan hienojakoisempaa kontrollia, voidaan operaatioiden kohdalla määritellä tarkemmin mitä oikeuksia tai mahdollisia toimintoja sillä on. Missä unix primitiivit ovat luku, kirjoitus ja suoritus, capsicumin kohdalla voidaan määritellä useita oikeuksia maskeilla. Esimerkiksi voidaan sallia kirjoitus mutta estää tiedostossa liikkuminen. Tällöin kirjotius on mahdollista vain tiedostossa tiettyyn kohtaan. Tämä konsepti oli aluksi hankala käsittää sen esittävästä julkaisusta, videoluento auttoi tässä huomattavasti eteenpäin. Mielestäni tässä on ajatuksena siirtyä ohjelmien kohdalla kohti usean eristetyn proessin mallia, yhden massiivisen prosesin sijasta. Kun edellinen kohta liitetään tarkempaan oikeuksien hallintaa voidaan rajoittaa ensimmäisien luentojen hyökkäyksiä. Hyvä pointi tuli esille, missä jos capsicumissa käytetään fd:tä esittämään verkkoresurssia ja jostain syystä yhteys katkeaa, miten tästä selvitään eteenpäin? Pitäisi avata uusi fd tähän resurssiin ja palata uudestaan hiekkalaatikko-tilaan. Kuullostaa hankaalta käytännössä ja mahdollisesti aiheuttaa palvelun käyttökatkoja.
